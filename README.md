**Лабораторная работа №2**

**Выполнил:** Гаврилович Вероника Вячеславовна  
**Группа:** P3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure  
**Вариант:** `rb-dict`

---

### Тема

Реализация структуры данных Dictionary (ассоциативный словарь) на основе красно-чёрного дерева (Red-Black Tree).

---

### Цель работы

Закрепить навыки функционального программирования, реализовав неизменяемую, полиморфную, рекурсивную структуру данных, обеспечивающую:

- добавление и удаление элементов;
- получение значений по ключу;
- фильтрацию (`dict-filter`);
- отображение (`dict-map`);
- свёртки (`dict-foldl`, `dict-foldr`);
- поддержку алгебраической структуры моноида;
- эффективное сравнение структур данных;
- модульное и property-based тестирование.

---

### Основные функции API

#### Базовые операции словаря

| Функция       | Назначение                        |
|---------------|-----------------------------------|
| `empty-dict`  | Создание пустого словаря          |
| `insert`      | Добавление пары (ключ, значение)  |
| `remove-key`  | Удаление ключа                    |
| `lookup`      | Получение значения по ключу       |
| `dict->seq`   | Список ключей в порядке сортировки|
| `mappend`     | Объединение двух словарей (моноид)|
| `equal?`      | Проверка равенства словарей       |

#### Функции высшего порядка

Благодаря реализации стандартных протоколов Clojure (`Seqable`, `Associative`, `ILookup`, `Counted`, `IFn`) словарь можно использовать как обычную коллекцию.

| Функция       | Назначение                        | Пример                                      |
|---------------|-----------------------------------|---------------------------------------------|
| `map`         | Отображение значений              | `(dict-map d (fn [k v] (* v 2)))`           |
| `filter`      | Фильтрация по (k, v)              | `(dict-filter d (fn [k v] (> v 10)))`       |
| `reduce`      | Свёртка                           | `(dict-foldl d f init)`                     |
| `seq`         | Список ключей                     | `(seq d)`                                   |
| `get`         | Получение значения                | `(get d k)`                                 |
| `contains?`   | Проверка существования ключа      | `(contains? d k)`                           |
| `assoc`       | Добавление пары                   | `(assoc d k v)`                             |
| `conj`        | Добавление пары                   | `(conj d [k v])`                            |

---

### Структура данных

Словарь реализован на основе красно-чёрного дерева, где каждый узел содержит:

```clojure
{:color :red/:black
 :key   k
 :value v
 :left  left-subtree
 :right right-subtree}
```

**Особенности:**

- логарифмическое время операций вставки, поиска и удаления;
- после каждой вставки выполняется балансировка дерева (LL, LR, RL, RR);
- структура неизменяема — каждая операция создаёт новое дерево;
- внутренняя реализация скрыта — пользователю доступен только интерфейс `IDict`.

---

### Реализация (ключевые элементы)

#### Добавление (`insert`)

Реализовано через рекурсивную вставку с последующей балансировкой:

```clojure
(dict-insert [this k v]
  (->RBDict (insert-node (:cmp this) (:root this) k v)
            (:cmp this)))
```

### Реализация (ключевые элементы)

#### Удаление (`remove-key`)

Удаление реализовано через:

- inorder-обход дерева → отсортированный список;
- фильтрацию ключа;
- перестройку сбалансированного дерева.

Гарантирует неизменяемость и корректность.

#### Поиск (`lookup`)

```clojure
(dict-lookup [this k] (lookup-value (:cmp this) (:root this) k))
```

Логарифмическая сложность

#### Map и Filter

Создают новое дерево, проходя по узлам:

```(dict-map [this f] (->RBDict (map-node f (:root this)) (:cmp this)))
(dict-filter [this pred] (->RBDict (filter-node pred (:root this)) (:cmp this)))
```

#### Foldl и Foldr

Левый и правый inorder-обход:

```(dict-foldl [this f init] (foldl-node (:root this) f init))
(dict-foldr [this f init] (foldr-node (:root this) f init))
```

#### Моноид
```(dict-mempty [this] 
  (dict-empty this))

(dict-mappend [this other]
  (reduce (fn [d [k v]] (insert d k v))
          this
          (inorder (:root other))))
```

#### Эффективное сравнение
```(dict-equal? [this other]
  (= (inorder (:root this))
     (inorder (:root other))))
```


Сложность — O(n) без сортировки.

#### Примеры использования
```(def d
  (-> empty-dict
      (insert 3 "c")
      (insert 1 "a")
      (insert 2 "b")))

(seq d)          ; => (1 2 3)
(lookup d 2)     ; => "b"
(get d 10)       ; => nil
(count d)        ; => 3

(dict-map d (fn [k v] (str v "!")))
;; => {"a!" "b!" "c!"}

(dict-filter d (fn [k v] (even? k)))
;; => словарь только с ключом 2

(mappend d d)
(equal? d d)     ; => true
```

### Тестирование
#### Unit-тесты (test/rb_dict/unit_test.clj)

Покрывают:

-insert, remove-key, lookup;
-dict-map, dict-filter;
-foldl, foldr;
-корректность протоколов коллекций;
-свойства моноида;
-сравнение словарей.

#### Property-based тестирование (test/rb_dict/property_test.clj)

Проверено:

-нейтральный элемент моноида;
-ассоциативность mappend;
-insert гарантирует корректный lookup;
-remove приводит к удалению ключа;
-map сохраняет множество ключей;
-filter уменьшает или сохраняет размер;
-равенство рефлексивно и симметрично.

#### Генераторы (test/rb_dict/generators.clj)

Создают:

-случайные пары (ключ, значение),
-случайные словари,
-словари с гарантированно существующим ключом.

## Выводы

В ходе работы была реализована:
функциональная, неизменяемая структура данных Dictionary на основе красно-чёрного дерева;
поддержка операций вставки, удаления, поиска, map, filter, foldl/foldr;
корректная реализация свойств моноида;
интеграция со стандартными коллекционными протоколами Clojure;
эффективное сравнение структур без сортировки;
полноценное модульное и property-based тестирование.
Работа позволила закрепить ключевые концепции функционального программирования:
иммутабельность, рекурсия, композиция функций, алгебраические свойства структур данных.
