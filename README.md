# Лабораторная работа №2

Выполнила: Гаврилович Вероника Вячеславовна

Группа: Р3331

Преподаватель: Пенской Александр Владимирович

Язык: Clojure

## Задача

Реализовать структуру данных словарь (dict) с интерфейсом на основе красно-черного дерева (Red-Black Tree)

## Ключевые элементы реализации

Протокол словаря:

```clojure
(defprotocol IDict
  (dict-empty [this] "Пустой словарь")
  (dict-insert [this k v] "Добавляет элемент")
  (dict-remove [this k] "Удаляет элемент")
  (dict-lookup [this k] "Возвращает значение или nil")

  (dict-map [this f] "f k v -> v' : отображение")
  (dict-filter [this pred] "pred k v -> bool")

  (dict-foldl [this f init] "Левая свёртка")
  (dict-foldr [this f init] "Правая свёртка")

  (dict-mempty [this])
  (dict-mappend [this other])

  (dict-equal? [this other]))
```

Реализация протокола на основе красно-черного дерева:

```clojure
(deftype RBDict [root cmp]
  api/IDict
  (dict-empty [_] (RBDict. nil compare))
  (dict-insert [this k v] (RBDict. (insert-node cmp root k v) cmp))
  (dict-remove [this k] (RBDict. (remove-node cmp root k) cmp))
  (dict-lookup [this k] (lookup-value cmp root k))
  (dict-map [this f] (RBDict. (map-node f root) cmp))
  (dict-filter [this pred] (RBDict. (filter-node pred root) cmp))
  (dict-foldl [this f init] (foldl-node f init root))
  (dict-foldr [this f init] (foldr-node f init root))
  (dict-mempty [this] (RBDict. nil compare))
  (dict-mappend [this other] ...)
  (dict-equal? [this other] ...)
  
  ;; Реализация стандартных протоколов Clojure
  clojure.lang.Seqable
  (seq [this] ...)
  clojure.lang.Counted
  (count [this] ...)
  clojure.lang.ILookup
  (valAt [this k] ...)
  clojure.lang.Associative
  (assoc [this k v] ...)
  clojure.lang.IPersistentCollection
  (cons [this o] ...)
  clojure.lang.IFn
  (invoke [this k] ...))
```

Само красно-черное дерево реализовано таким образом: у каждого узла есть цвет (красный или черный), ключ, значение, левое и правое поддеревья.

```clojure
(defrecord RBNode [color key value left right])
(deftype RBDict [root cmp])
```

Структура данных иммутабельна, является моноидом и полиморфна. Эти свойства проверены в тестах.

## Основные реализованные функции

`insert-node [cmp root k v]` - добавляет пару ключ-значение в дерево. Создает новый узел красного цвета, рекурсивно находит место для вставки, затем балансирует дерево при возврате из рекурсии для сохранения свойств красно-черного дерева. Корень всегда окрашивается в черный цвет.

`lookup-node [cmp node k]` - поиск узла по ключу. Сравнивает искомый ключ с ключом текущего узла и рекурсивно спускается влево (если меньше) или вправо (если больше). Сложность O(log n).

`balance [color k v left right]` - балансировка дерева после вставки. Проверяет 4 случая нарушения свойств красно-черного дерева:
- LEFT-LEFT: два красных узла подряд слева-слева
- LEFT-RIGHT: два красных узла подряд слева-справа
- RIGHT-LEFT: два красных узла подряд справа-слева
- RIGHT-RIGHT: два красных узла подряд справа-справа

Исправляет нарушения через ротации и перекраску узлов.

`remove-node [cmp root k]` - удаляет элемент из словаря. Реализовано через получение всех элементов в отсортированном порядке (inorder traversal), фильтрацию нужного элемента и построение нового сбалансированного дерева из оставшихся.

`inorder [node]` - обход дерева в порядке возрастания ключей (левое поддерево → корень → правое поддерево). Возвращает список пар [ключ значение].

`from-sorted [pairs]` - построение сбалансированного дерева из отсортированного списка пар. Берет средний элемент как корень, рекурсивно строит левое и правое поддеревья.

`map-node [f node]` - применяет функцию к каждому значению в дереве. Ключи и структура дерева не изменяются, создается новое дерево с преобразованными значениями.

`filter-node [pred node]` - фильтрация элементов по предикату. Оставляет только элементы, для которых предикат вернул true.

`foldl-node [f acc node]` - левая свертка. Обрабатывает элементы в порядке: левое поддерево → корень → правое поддерево. Аккумулятор передается слева направо.

`foldr-node [f acc node]` - правая свертка. Обрабатывает элементы в порядке: правое поддерево → корень → левое поддерево. Аккумулятор передается справа налево.

`dict-mappend [this other]` - объединение двух словарей (моноидальная операция). Все элементы из второго словаря вставляются в первый через reduce.

Нейтральным элементом является `empty-dict` - пустой словарь с корнем `nil` и стандартной функцией сравнения `compare`.

## Реализация стандартных протоколов Clojure

Для интеграции с экосистемой Clojure реализованы стандартные Java-интерфейсы:

**clojure.lang.Seqable** - позволяет преобразовать словарь в последовательность через `seq`. Возвращает ключи в отсортированном порядке.

**clojure.lang.Counted** - позволяет использовать `count` для подсчета элементов.

**clojure.lang.ILookup** - позволяет использовать `get` и `get` с дефолтным значением для поиска элементов.

**clojure.lang.Associative** - позволяет использовать `assoc` для добавления элементов, `contains?` для проверки наличия ключа, и `entryAt` для получения пары ключ-значение.

**clojure.lang.IPersistentCollection** - позволяет использовать `conj` для добавления пар [ключ значение] и `empty` для создания пустого словаря.

**clojure.lang.IFn** - позволяет использовать словарь как функцию: `(my-dict key)` вместо `(get my-dict key)`.

Благодаря этому наш словарь работает со всеми стандартными функциями Clojure.

## Тестирование

В файле `unit_test.clj` находятся unit-тесты для проверки конкретных сценариев. В файле `property_test.clj` находятся property-based тесты для проверки свойств на случайных данных. В файле `generators.clj` реализованы генераторы для создания случайных тестовых данных.

### Генераторы

`gen-int` - генератор случайных целых чисел.

`gen-pair` - генератор пар [ключ значение], где ключ и значение - случайные числа.

`gen-pairs` - генератор списка пар от 0 до 20 элементов.

`gen-dict` - генератор словарей. Создает словарь из сгенерированного списка пар через последовательную вставку элементов.

### Проверяемые свойства в property-based тестах

**Свойства моноида:**
- `monoid-identity` - проверка нейтрального элемента: `d ⊕ empty = empty ⊕ d = d`
- `monoid-assoc` - проверка ассоциативности: `(d1 ⊕ d2) ⊕ d3 = d1 ⊕ (d2 ⊕ d3)`

**Свойства операций:**
- `insert-contains` - после вставки элемент можно найти
- `remove-removes` - после удаления элемент не найден
- `map-keeps-keys` - map сохраняет множество ключей
- `filter-reduces` - filter не увеличивает размер словаря

**Свойства стандартных протоколов:**
- `seqable-sorted` - seq возвращает ключи в отсортированном порядке
- `counted-correct` - count возвращает количество уникальных ключей
- `ilookup-consistent` - get согласован с dict-lookup
- `associative-insert` - assoc работает как dict-insert
- `persistent-collection-conj` - conj работает как dict-insert
- `ifn-lookup` - вызов словаря как функции согласован с dict-lookup

**Свойства сверток:**
- `foldl-sum` - левая свертка корректно суммирует значения
- `foldr-sum` - правая свертка дает ту же сумму, что и левая (для ассоциативной операции)

Каждое свойство проверяется на 100 случайно сгенерированных тестовых случаях. Итого: **1400 проверок** (14 свойств × 100 итераций).

## Выводы

В этой лабораторной работе я изучила создание пользовательских типов данных и полиморфизм в Clojure. Получилось отделить интерфейс словаря от его реализации через протоколы - протокол `IDict` описывает, что должен уметь словарь, а `deftype RBDict` реализует это через красно-черное дерево. 
Также я реализовала стандартные протоколы Clojure (`Seqable`, `Counted`, `ILookup` и другие), благодаря чему мой словарь можно использовать с обычными функциями языка: `count`, `get`, `assoc` и даже вызывать словарь как функцию.

Структура данных полностью иммутабельна - каждая операция создает новую версию словаря, не трогая старую. Это удобно для многопоточности и отладки.

Я познакомилась с property-based тестированием через библиотеку test.check. Вместо того чтобы писать конкретные примеры, я описала свойства, которые должны выполняться для любых данных (например, "после вставки элемент можно найти"). Библиотека сама генерирует 100 случайных тестов для каждого свойства и проверяет их. Получилось 14 свойств × 100 итераций = 1400 проверок.

Красно-черное дерево обеспечивает O(log n) для вставки и поиска за счет балансировки после каждой вставки.
